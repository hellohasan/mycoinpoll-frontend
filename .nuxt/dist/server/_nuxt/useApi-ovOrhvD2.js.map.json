{"file":"useApi-ovOrhvD2.js","mappings":";;;AAGO,SAAS,SAAS;AACvB,QAAM,SAAS,iBAAiB;AAChC,QAAM,OAAO,aAAa;AACpB,QAAA,EAAE,WAAW,IAAI,cAAc;AAErC,QAAM,eAAe,OAA8B;AAAA,IACjD,SAAS,OAAO,OAAO;AAAA;AAAA,IAGvB,UAAU,EAAE,WAAW;AACrB,UAAI,KAAK,OAAO;AACV,YAAA,EAAE,QAAQ,mBAAmB,UAAU;AACzC,kBAAQ,UAAU,IAAI,QAAQ,QAAQ,OAAO;AAAA,QAAA;AAE/C,gBAAQ,QAAQ,IAAI,iBAAiB,UAAU,KAAK,KAAK,EAAE;AAAA,MAAA;AAAA,IAE/D;AAAA;AAAA,IAGA,eAAe,EAAE,SAAS;AAEjB,aAAA,QAAQ,OAAO,KAAK;AAAA,IAC7B;AAAA;AAAA,IAGA,WAAW,EAAE,YAAY;AACvB,aAAO,SAAS;AAAA,IAClB;AAAA;AAAA,IAGA,gBAAgB,EAAE,OAAO,YAAY;;AACnC,cAAQ,qCAAU,QAAQ;AAAA,QACxB,KAAK;AACH,eAAK,OAAO;AACD,uBAAA,cAAS,UAAT,mBAAgB,YAAW,8BAA8B;AACpE,qBAAW,aAAa;AACxB;AAAA,QACF,KAAK;AAEH;AAAA,QACF,KAAK;AAEH;AAAA,QACF,KAAK;AAEH;AAAA,QACF;AACa,uBAAA,0CAAU,UAAV,mBAAiB,YAAW,mBAAmB;AAAA,MAAA;AAEvD,aAAA,QAAQ,OAAO,KAAK;AAAA,IAAA;AAAA,EAC7B;AAIF,QAAM,eAAe,CAAI,KAAa,OAAoC,CAAA,MAAO;AACzE,UAAA,OAAO,IAAc,IAAI;AACzB,UAAA,UAAU,IAAI,KAAK;AACnB,UAAA,QAAQ,IAAmB,IAAI;AAErC,UAAM,YAAY,YAAY;AAC5B,cAAQ,QAAQ;AAChB,YAAM,QAAQ;AACV,UAAA;AACF,cAAM,WAAW,MAAM,OAAU,KAAK,EAAE,GAAI,aAAA,GAA2B,GAAG,MAAM,QAAQ,KAAK,UAAU,OAAO;AAC9G,aAAK,QAAQ;AAAA,eACN,KAAU;AACX,cAAA,QAAQ,IAAI,WAAW;AAAA,MAAA,UAC7B;AACA,gBAAQ,QAAQ;AAAA,MAAA;AAAA,IAEpB;AACU,cAAA;AACV,WAAO,EAAE,MAAM,SAAS,OAAO,SAAS,UAAU;AAAA,EACpD;AAEO,SAAA;AAAA;AAAA,IAEL,SAAS,OAAU,KAAa,OAA2B,OAAO;AAChE,aAAO,MAAM,OAAU,KAAK,EAAE,GAAI,aAA2B,GAAA,GAAG,MAAM,QAAQ,KAAK,UAAU,OAAO;AAAA,IACtG;AAAA;AAAA,IAGA;AAAA;AAAA,IAGA,YAAY,CAAI,KAAa,OAA2B,OAAO;AAC7D,aAAO,SAAY,KAAK,EAAE,GAAI,aAAgB,GAAW,GAAG,MAAM,QAAQ,KAAK,UAAU,MAAA,gBAAO;AAAA,IAClG;AAAA;AAAA,IAGA,gBAAgB,CAAI,KAAa,OAA2B,OAAO;AACjE,aAAO,aAAgB,KAAK,EAAE,GAAI,aAAgB,GAAW,GAAG,MAAM,QAAQ,KAAK,UAAU,MAAA,gBAAO;AAAA,IAAA;AAAA,EAExG;AACF;","names":[],"sources":["../../../../composables/useApi.ts"],"sourcesContent":["// composables/useApi.ts\nimport type { UseFetchOptions } from \"nuxt/app\";\n\nexport function useApi() {\n  const config = useRuntimeConfig();\n  const auth = useAuthStore();\n  const { toastError } = useToastAlert();\n\n  const fetchOptions = <T>(): UseFetchOptions<T> => ({\n    baseURL: config.public.apiBase,\n\n    // Request Interceptor\n    onRequest({ options }) {\n      if (auth.token) {\n        if (!(options.headers instanceof Headers)) {\n          options.headers = new Headers(options.headers);\n        }\n        options.headers.set(\"Authorization\", `Bearer ${auth.token}`);\n      }\n    },\n\n    // Handle Request Errors\n    onRequestError({ error }) {\n      toastError(\"An error occurred while sending the request\");\n      return Promise.reject(error);\n    },\n\n    // Response Interceptor\n    onResponse({ response }) {\n      return response._data;\n    },\n\n    // Handle Response Errors\n    onResponseError({ error, response }) {\n      switch (response?.status) {\n        case 401:\n          auth.$reset();\n          toastError(response._data?.message || \"Unauthorized! Please log in.\");\n          navigateTo(\"/auth/login\");\n          break;\n        case 403:\n          toastError(\"Access denied! or Invalid request!\");\n          break;\n        case 404:\n          toastError(\"Requested resource not found.\");\n          break;\n        case 500:\n          toastError(\"Internal server error.\");\n          break;\n        default:\n          toastError(response?._data?.message || \"An error occurred\");\n      }\n      return Promise.reject(error);\n    },\n  });\n\n  // ✅ my Fetch with `pending`, `error`, and `refresh`\n  const useOnlyFetch = <T>(url: string, opts: Partial<UseFetchOptions<T>> = {}) => {\n    const data = ref<T | null>(null);\n    const pending = ref(false);\n    const error = ref<string | null>(null);\n\n    const fetchData = async () => {\n      pending.value = true;\n      error.value = null;\n      try {\n        const response = await $fetch<T>(url, { ...(fetchOptions<T>() as any), ...opts, method: opts.method || \"GET\" });\n        data.value = response;\n      } catch (err: any) {\n        error.value = err.message || \"Something went wrong!\";\n      } finally {\n        pending.value = false;\n      }\n    };\n    fetchData();\n    return { data, pending, error, refresh: fetchData };\n  };\n\n  return {\n    // For mutations (POST, PUT, DELETE)\n    myFetch: async <T>(url: string, opts: UseFetchOptions<T> = {}) => {\n      return await $fetch<T>(url, { ...(fetchOptions<T>() as any), ...opts, method: opts.method || \"GET\" });\n    },\n\n    // ✅ my Fetch for GET requests with pending/error states (POST, PUT, DELETE)\n    useOnlyFetch,\n\n    // For SSR-supported data fetching\n    useMyFetch: <T>(url: string, opts: UseFetchOptions<T> = {}) => {\n      return useFetch<T>(url, { ...(fetchOptions<T>() as any), ...opts, method: opts.method || \"GET\" });\n    },\n\n    // For lazy loading data\n    useMyLazyFetch: <T>(url: string, opts: UseFetchOptions<T> = {}) => {\n      return useLazyFetch<T>(url, { ...(fetchOptions<T>() as any), ...opts, method: opts.method || \"GET\" });\n    },\n  };\n}\n"],"version":3}