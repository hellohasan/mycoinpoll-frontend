import{Z as F,cs as p,r as C,bD as $,bI as z,B as M,bc as U,bk as j,c0 as B,bi as T,aQ as L,ct as H,u as K,y as G,cu as I,br as S,cv as k,bK as y,Q as V,U as x,i as A}from"./--rz71Vb.js";import{u as Z}from"./-HW9Rane.js";const N=s=>s==="defer"||s===!1;function Q(...s){var w;const r=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(r);let[a,o,t={}]=s;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const e=F(),u=o,h=()=>p.value,E=()=>e.isHydrating?e.payload.data[a]:e.static.data[a];t.server=t.server??!0,t.default=t.default??h,t.getCachedData=t.getCachedData??E,t.lazy=t.lazy??!1,t.immediate=t.immediate??!0,t.deep=t.deep??p.deep,t.dedupe=t.dedupe??"cancel";const m=t.getCachedData(a,e),v=m!=null;if(!e._asyncData[a]||!t.immediate){(w=e.payload._errors)[a]??(w[a]=p.errorValue);const c=t.deep?C:$;e._asyncData[a]={data:c(v?m:t.default()),pending:C(!v),error:z(e.payload._errors,a),status:C("idle"),_default:t.default}}const n={...e._asyncData[a]};delete n._default,n.refresh=n.execute=(c={})=>{if(e._asyncDataPromises[a]){if(N(c.dedupe??t.dedupe))return e._asyncDataPromises[a];e._asyncDataPromises[a].cancelled=!0}if(c._initial||e.isHydrating&&c._initial!==!1){const l=c._initial?m:t.getCachedData(a,e);if(l!=null)return Promise.resolve(l)}n.pending.value=!0,n.status.value="pending";const d=new Promise((l,i)=>{try{l(u(e))}catch(_){i(_)}}).then(async l=>{if(d.cancelled)return e._asyncDataPromises[a];let i=l;t.transform&&(i=await t.transform(l)),t.pick&&(i=W(i,t.pick)),e.payload.data[a]=i,n.data.value=i,n.error.value=p.errorValue,n.status.value="success"}).catch(l=>{if(d.cancelled)return e._asyncDataPromises[a];n.error.value=H(l),n.data.value=K(t.default()),n.status.value="error"}).finally(()=>{d.cancelled||(n.pending.value=!1,delete e._asyncDataPromises[a])});return e._asyncDataPromises[a]=d,e._asyncDataPromises[a]},n.clear=()=>X(e,a);const g=()=>n.refresh({_initial:!0}),D=t.server!==!1&&e.payload.serverRendered;{const c=M();if(c&&D&&t.immediate&&!c.sp&&(c.sp=[]),c&&!c._nuxtOnBeforeMountCbs){c._nuxtOnBeforeMountCbs=[];const i=c._nuxtOnBeforeMountCbs;U(()=>{i.forEach(_=>{_()}),i.splice(0,i.length)}),j(()=>i.splice(0,i.length))}D&&e.isHydrating&&(n.error.value||m!=null)?(n.pending.value=!1,n.status.value=n.error.value?"error":"success"):c&&(e.payload.serverRendered&&e.isHydrating||t.lazy)&&t.immediate?c._nuxtOnBeforeMountCbs.push(g):t.immediate&&g();const d=L();if(t.watch){const i=B(t.watch,()=>n.refresh());d&&T(i)}const l=e.hook("app:data:refresh",async i=>{(!i||i.includes(a))&&await n.refresh()});d&&T(l)}const b=Promise.resolve(e._asyncDataPromises[a]).then(()=>n);return Object.assign(b,n),b}function X(s,r){r in s.payload.data&&(s.payload.data[r]=void 0),r in s.payload._errors&&(s.payload._errors[r]=p.errorValue),s._asyncData[r]&&(s._asyncData[r].data.value=void 0,s._asyncData[r].error.value=p.errorValue,s._asyncData[r].pending.value=!1,s._asyncData[r].status.value="idle"),r in s._asyncDataPromises&&(s._asyncDataPromises[r]&&(s._asyncDataPromises[r].cancelled=!0),s._asyncDataPromises[r]=void 0)}function W(s,r){const a={};for(const o of r)a[o]=s[o];return a}function R(s,r,a){const[o={},t]=typeof r=="string"?[{},r]:[r,a],e=G(()=>y(s)),u=o.key||I([t,typeof e.value=="string"?e.value:"",...Y(o)]);if(!u||typeof u!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+u);if(!s)throw new Error("[nuxt] [useFetch] request is missing.");const h=u===t?"$f"+u:u;if(!o.baseURL&&typeof e.value=="string"&&e.value[0]==="/"&&e.value[1]==="/")throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:E,lazy:m,default:v,transform:n,pick:g,watch:D,immediate:b,getCachedData:w,deep:c,dedupe:d,...l}=o,i=S({...k,...l,cache:typeof o.cache=="boolean"?void 0:o.cache}),_={server:E,lazy:m,default:v,transform:n,pick:g,immediate:b,getCachedData:w,deep:c,dedupe:d,watch:D===!1?[]:[i,e,...D||[]]};let f;return Q(h,()=>{var O;(O=f==null?void 0:f.abort)==null||O.call(f,new DOMException("Request aborted as another request to the same endpoint was initiated.","AbortError")),f=typeof AbortController<"u"?new AbortController:{};const q=y(o.timeout);let P;return q&&(P=setTimeout(()=>f.abort(new DOMException("Request aborted due to timeout.","AbortError")),q),f.signal.onabort=()=>clearTimeout(P)),(o.$fetch||globalThis.$fetch)(e.value,{signal:f.signal,...i}).finally(()=>{clearTimeout(P)})},_)}function J(s,r,a){const[o={},t]=typeof r=="string"?[{},r]:[r,a];return R(s,{...o,lazy:!0},t)}function Y(s){var a;const r=[((a=y(s.method))==null?void 0:a.toUpperCase())||"GET",y(s.baseURL)];for(const o of[s.params||s.query]){const t=y(o);if(!t)continue;const e={};for(const[u,h]of Object.entries(t))e[y(u)]=y(h);r.push(e)}return r}function re(){const s=x(),r=V(),{toastError:a}=Z(),o=()=>({baseURL:s.public.apiBase,credentials:"include",onRequest({options:t}){const e=new Headers({Accept:"application/json","Content-Type":"application/json","X-Requested-With":"XMLHttpRequest"});r.token&&e.set("Authorization",`Bearer ${r.token}`),t.headers=e},onRequestError({error:t}){return a("An error occurred while sending the request"),Promise.reject(t)},onResponse({response:t}){return t._data},onResponseError({error:t,response:e}){var u,h;switch(e==null?void 0:e.status){case 401:r.$reset(),a(((u=e._data)==null?void 0:u.message)||"Unauthorized! Please log in."),A("/auth/login");break;case 403:a("Access denied! or Invalid request!");break;case 404:a("Requested resource not found.");break;case 500:a("Internal server error.");break;default:a(((h=e==null?void 0:e._data)==null?void 0:h.message)||"An error occurred")}return Promise.reject(t)}});return{myFetch:async(t,e={})=>await $fetch(t,{...o(),...e,method:e.method||"GET"}),useOnlyFetch:(t,e={})=>R(t,{...o(),...e,method:e.method||"GET",server:!1},"$UqgiltlUfE"),useMyFetch:(t,e={})=>R(t,{...o(),...e,method:e.method||"GET"},"$HgqqyPIEgZ"),useMyLazyFetch:(t,e={})=>J(t,{...o(),...e,method:e.method||"GET"},"$szE3KFZK0G")}}export{R as a,re as u};
